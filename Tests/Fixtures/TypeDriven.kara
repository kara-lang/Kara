protocol Monad {
  associatedtype Element

  static func new(_: Element) -> Self(Element)

  func flatMap(_: Element -> Self(NewElement)) -> Self(NewElement)
}

enum Result(Value, Error) {
  case success(_: Value)
  case failure(_: Error)
}

extension Result: Monad {
    typealias Element = Value

    static func new(_ v: Value) { .success(v) }

    func flatMap(binder: Value -> Result(NewValue)) -> Result(NewValue) {
        switch self {
        case .success(value):
            switch binder(value) {
                case .success(newValue):
                    .success(newValue)
                case .failure(error):
                    .failure(error)
            }
        case .failure(error):
            .failure(error)
        }
    }
}

let x: Result(Int, Error) = do {
  let y = try blah()
  let z = try blah()

  return y + z
}

let x = blah().flatMap { y in
  blah().flatMap { z in
    y + z
  }
}

func square(a: Int) -> Int = multiply(a, a)

func factorial(Int) -> Int
factorial(0) = 1
factorial(n) = multiply(n, (n - 1))

func fill(count: Nat, e: Element) -> Vec(count, Element)

enum Nat {
    case zero
    case addOne(Nat)
}

enum Vec(count: Nat, Element) {
    case empty -> Vec(.zero, Element)
    case cons(Element, Vec(count, Element)) -> Vec(.addOne(count), Element)
}

func allCounts(vector: Vec(n, String)) -> Vec(n, m) {
    switch vector {
    case []:
        []
    case let .cons(str, rest):
        .cons(str.count, allCounts(rest))
}
